










DESC="点击按钮复制当前服务器名称"，
按钮={{
标题="复制"，
图标="复制"，
variant="Primary"，
回调=函数()
本地placename=game:GetService("MarketplaceService")：GetProductInfo(game.placeId)。姓名
setclipboard(地名)
本地声音=Instance.new("声音"，游戏：GetService("声音服务"))
Sound.SoundId="rbxassetid://138820873376530"
声音：播放()
WindUI：通知({
title="WX："，
内容="已成功复制服务器名称！"，
icon="bell"，
IconThemed=true，
持续时间=5
            })
结束
    }}
})

局部段落7=TabHandles.WX1：段落({
标题="复制注册时间"，
DESC="点击按钮复制账号注册天数"，
按钮={{
标题="复制"，
图标="复制"，
variant="Primary"，
回调=函数()
本地会计=toString(游戏：GetService("玩家").LocalPlayer.Accountage).."天"
setclipboard(会计)
本地声音=Instance.new("声音"，游戏：GetService("声音服务"))
Sound.SoundId="rbxassetid://138820873376530"
声音：播放()
WindUI：通知({
title="WX："，
内容="已成功复制注册时间！"，
icon="bell"，
IconThemed=true，
持续时间=5
            })
结束
    }}
})

--开关功能能关闭
局部切换1=TabHandles.WX2：切换({
标题="夜视功能"，
值=false，
回调=函数(值)
如果值，则
game.Lighting.Ambient=Color3.new(1，1，1)
其他
game.Lighting.Ambient=Color3.new(0，0，0)
结束
WindUI：通知({
title="WX"，
内容=值和“”已开启"或"已关闭"，
持续时间=3，
图标="布局网格"，
        })
结束
})

--====================自瞄系统页面====================
-- 自瞄设置区域
当地的AimSection1=TabHandles.WX3:Section({Title="自瞄设置"})

目标部分1：切换({
标题="自瞄开关"，
DESC="开启/关闭自瞄功能"，
值=false，
回调=函数(值)
ToggleAim(值)
结束
})

目标部分1：切换({
标题="预测自瞄"，
DESC="根据目标移动预测瞄准位置"，
值=false，
回调=函数(值)
UsePrediction=value
结束
})

目标部分1：切换({
标题="优先最低血量"，
DESC="优先瞄准血量最低的玩家"，
值=false，
回调=函数(值)
TargetLowestHealth=value
结束
})

目标部分1：滑块({

TabHandles.WX4：按钮({
标题="传送到玩家旁边"，
DESC="传送到选中玩家的旁边"，
图标="导航"，
回调=函数()
如果selectedPlayer和selectedPlayer.Character和selectedPlayer。字符：FindFirstChild("HumanoidRootPart")然后
本地targetPos=selectedPlayer。性格。HumanoidRootPart。位置
游戏。玩家。本地玩家。性格。HumanoidRootPart。cframe=cframe.New(targetPos+Vector3.新的(3，0，3))
WindUI：通知({
title="WX"，
内容="已传送到"..selectedPlayer.Name.."旁边"，
持续时间=3，
图标=“导航”
            })
其他
WindUI：通知({
title="WX"，
内容="请先选择一个有效玩家"，
持续时间=3，
icon="alert-triangle"

DESC="吸人、甩飞等高级功能"，
image="wind"，
imagesize=20
})

-- 甩飞一次选中的人
TabHandles.WX4：按钮({

DESC="甩飞一次选中的玩家"，
icon="wind"，
回调=函数()
本地玩家=游戏：GetService("玩家").LocalPlayer
本地TargetPlayer=selectedPlayer
如果不是TargetPlayer或TargetPlayer==Player，则
WindUI：通知({
title="WX"，
内容="无玩家可甩飞"，
持续时间=3，
icon="alert-triangle"
            })
返回
结束

本地消息=功能(_标题、_文本、时间)
WindUI：通知({
title=_Title，
内容=_文本，
持续时间=时间，
图标=“铃”
            })
结束

本地PID=game.PlaceId
如果pid==189707，则
本地Rs=game:GetService("RunService")
local hb=rs.Heartbeat
本地RSD=rs.Render步进
local lp=game.Players.LocalPlayer
局部z=Vector3.zero
局部函数f(c)
本地R=c:WaitForChild("HumanoidRootPart")
如果r，则
局部con
con=hb：连接(函数()
如果不是R.父母，则
反对：断开()
结束
局部v=r.AssemblyLinearVelocity
r.AssemblyLinearVelocity=z
RSD:Wait()
r.AssemblyLinearVelocity=v
结束)
结束
结束
F(lp.Character)
lp.CharacterAdded:Connect(f)
结束

局部SkidFling=函数(目标)
本地字符=玩家.字符
局部类人字符=字符和字符：FindFirstChildOfClass("类人字符")
局部根部件=类人和类人根部件
本地TCharacter=Target.Character
局部THumanoid=TCharacter和TCharacter:FindFirstChildOfClass("Humanoid")
局部TRootPart=THumanid和THumanid.rootPart
本地thead=TCharacter和TCharacter:FindFirstChild("Head")
本地附件=TCharacter和TCharacter:FindFirstChildOfClass("Accessory")
本地句柄=附件和附件：FindFirstChild("Handle")

如果不是(字符和类人和根部分和TCharacter和类人)，则
返回消息("WX"，"玩家已趋势"，2)
结束
如果人形的话。sit return Message("WX"，"目标处于坐姿"，2)end
如果不是TCharacter:FindFirstChildWhichISA("BasePart")，则返回消息("WX"，"玩家已趋势"，2)end

如果西德那么
workspace.CurrentCamera.CameraSubject=thead
elseif然后处理
workspace.CurrentCamera.CameraSubject=句柄
其他
workspace.CurrentCamera.CameraSubject=THumanid
结束

如果RootPart.Velocity.Magnitude<50，则
getgenv().OldPos=RootPart.CFrame
结束

局部FPOs=函数(Base Part、Pos、Ang)
RootPart.CFrame=CFrame.new(BasePart.Position)*Pos*Ang
字符：SetPrimaryPartCFrame(cframe.New(BasePart.位置)*Pos*Ang)
RootPart.Velocity=Vector3.new(9E7，9E7*10，9E7)
RootPart.RotVelocity=Vector3.new(9E8，9E8，9E8)
结束

本地SFBasePart=函数(BasePart)
本地等待时间=2
本地时间=刻度()
局部角度=0
重复
如果RootPart和THumanid，则
如果基座部件速度幅度<50，则
角度=角度+100
FPOs(BasePart，CFrame.new(0，1.5，0)+THumanoid.MoveDirection*BasePart.速度.幅度/0.95，CFrame.角度(数学rad(角度)，0，0)
task.wait()
FPOs(BasePart，CFrame.new(0，-1.5，0)+THumanoid.MoveDirection*BasePart.速度.幅度/0.95，CFrame.角度(数学rad(角度)，0，0)
task.wait()
FPOs(BasePart，CFrame.new(2.25，1.5，-2.25)+THumanoid.MoveDirection*BasePart.速度.幅度/0.95，CFrame.角度(数学rad(角度)，0，0)
task.wait()
FPOs(BasePart，CFrame.new(-2.25，-1.5，2.25)+THumanoid.MoveDirection*BasePart.速度.幅度/0.95，CFrame.角度(数学rad(角度)，0，0)
task.wait()
FPOs(BasePart，CFrame.new(0，1.5，0)+THumanid.MoveDirection，cframe.角度(数学。弧度(角度)，0，0))
task.wait()
FPOs(BasePart，CFrame.new(0，-1.5，0)+THumanid.MoveDirection，cframe.角度(数学。弧度(角度)，0，0))
task.wait()
其他
FPOs(BasePart，CFrame.new(0，1.5，THumanoid.WalkSpeed)，CFrame.Angles(math.rad(90)，0，0))
task.wait()
FPOs(BasePart，CFrame.new(0，-1.5，-THumanid.WalkSpeed)，CFrame.Angles(0，0，0))
                            task.wait()
                            FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                            task.wait()
                            
                            FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 0.95), CFrame.Angles(math.rad(90), 0, 0))
                            task.wait()
                            FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 0.95), CFrame.Angles(0, 0, 0))
                            task.wait()
                            FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 0.95), CFrame.Angles(math.rad(90), 0, 0))
                            task.wait()
                            FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                            task.wait()
                            FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                            task.wait()
                            FPos(BasePart, CFrame.new(0, -1.5 ,0), CFrame.Angles(math.rad(-90), 0, 0))
                            task.wait()
                            FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                            task.wait()
                        end
                    else
                        break
                    end
                until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= Target.Character or Target.Parent ~= game:GetService("Players") or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
            end

            workspace.FallenPartsDestroyHeight = 0/0
            local BV = Instance.new("BodyVelocity")
            BV.Name = "EpixVel"
            BV.Parent = RootPart
            BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
            BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)
            Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

            if TRootPart and THead then
                SFBasePart((TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 and THead or TRootPart)
            elseif TRootPart then
                SFBasePart(TRootPart)
            elseif THead then
                SFBasePart(THead)
            elseif Handle then
                SFBasePart(Handle)
            else

                                FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                                task.wait()
                            else
                                FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                                task.wait()
                                FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                                task.wait()
                                FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
task.wait()
                                
FPOs(BasePart，CFrame.new(0，1.5，TRootPart.速度.幅度/0.95)，CFrame.角度(math.rad(90)，0，0))
task.wait()
FPOs(BasePart，CFrame.new(0，-1.5，-TRootPart.速度.幅度/0.95)，CF帧.角度(0，0，0))
task.wait()
FPOs(BasePart，CFrame.new(0，1.5，TRootPart.速度.幅度/0.95)，CFrame.角度(math.rad(90)，0，0))
task.wait()
FPOs(BasePart，CFrame.new(0，-1.5，0)，CFrame.Angles(math.rad(90)，0，0))
task.wait()
FPOs(BasePart，CFrame.new(0，-1.5，0)，CFrame.Angles(0，0，0))
task.wait()
FPOs(BasePart，CFrame.new(0，-1.5，0)，CFrame.Angles(math.rad(-90)，0，0))
task.wait()
FPOs(BasePart，CFrame.new(0，-1.5，0)，CFrame.Angles(0，0，0))
task.wait()
结束
其他
打破
结束
直到“BasePart.Velocity.Magnitude”>500或“BasePart”。parent~=Target。角色或目标。Parent~=game:GetService(“玩家”)或THumanoid。坐姿或人形。健康状态<=0或勾选()>时间+等待时间
结束
                
                workspace.FallenPartsDestroyHeight = 0/0
                local BV = Instance.new("BodyVelocity")
                BV.Name = "EpixVel"
                BV.Parent = RootPart
                BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
                BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)
                Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
                
                if TRootPart and THead then
                    SFBasePart((TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 and THead or TRootPart)
                elseif TRootPart then
                    SFBasePart(TRootPart)
                elseif THead then
                    SFBasePart(THead)
                elseif Handle then
                    SFBasePart(Handle)
                end
                
                BV:Destroy()
                Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
                workspace.CurrentCamera.CameraSubject = Humanoid
                getgenv().FPDH = getgenv().FPDH or workspace.FallenPartsDestroyHeight
                
                repeat
                    RootPart.CFrame = getgenv().OldPos * CFrame.new(0, 0.5, 0)
                    Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, 0.5, 0))
                    Humanoid:ChangeState("GettingUp")
                    table.foreach(Character:GetChildren(), function(_, x)
                        if x:IsA("BasePart") then x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new() end
                    end)
                    task.wait()
                until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
                workspace.FallenPartsDestroyHeight = getgenv().FPDH
            end
            
            loopFlingConnection = RunService.Heartbeat:Connect(function()
                if loopFlingEnabled and selectedPlayer then
                    performFling()
                end
            end)
        else
            if loopFlingConnection then
                loopFlingConnection:Disconnect()
                loopFlingConnection = nil
            end
            WindUI:Notify({
                Title = "WX",
                Content = "锁定甩飞已关闭",
                Duration = 3,
                Icon = "x"
            })
        end
    end
})

-- 甩飞所有人
TabHandles.WX4:Button({
    Title = "甩飞所有人",
    Desc = "甩飞所有在线玩家",
    Icon = "users",
    Callback = function()
        local Targets = {"All"}
        local Players = game:GetService("Players")
        local Player = Players.LocalPlayer
        local AllBool = false
        local GetPlayer = function(Name)
            Name = Name:lower()
            if Name == "all" or Name == "others" then
                AllBool = true
                return
            elseif Name == "random" then
                local GetPlayers = Players:GetPlayers()
                if table.find(GetPlayers,Player) then table.remove(GetPlayers,table.find(GetPlayers,Player)) end
                return GetPlayers[math.random(#GetPlayers)]
            elseif Name ~= "random" and Name ~= "all" and Name ~= "others" then
                for _,x in next, Players:GetPlayers() do
                    if x ~= Player then
                        if x.Name:lower():match("^"..Name) then
                            return x;
                        elseif x.DisplayName:lower():match("^"..Name) then
                            return x;
                        end
                    end
                end
            else
                return
            end
        end
        
        local Message = function(_Title, _Text, Time)
            WindUI:Notify({
                Title = _Title,
                Content = _Text,
                Duration = Time,
                Icon = "bell"
            })
        end
        
        local SkidFling = function(TargetPlayer)
            local Character = Player.Character
            local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
            local RootPart = Humanoid and Humanoid.RootPart
            local TCharacter = TargetPlayer.Character
            local THumanoid
            local TRootPart
            local THead
            local Accessory
            local Handle
            if TCharacter:FindFirstChildOfClass("Humanoid") then
                THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
            end
            if THumanoid and THumanoid.RootPart then
                TRootPart = THumanoid.RootPart
            end
            if TCharacter:FindFirstChild("Head") then
                THead = TCharacter.Head
            end
            if TCharacter:FindFirstChildOfClass("Accessory") then
                Accessory = TCharacter:FindFirstChildOfClass("Accessory")
            end
            if Accessory and Accessory:FindFirstChild("Handle") then
                Handle = Accessory.Handle
            end
            if Character and Humanoid and RootPart then
                if RootPart.Velocity.Magnitude < 50 then
                    getgenv().OldPos = RootPart.CFrame
                end
                if THumanoid and THumanoid.Sit and not AllBool then
                    return Message("WX", "目标处于坐姿", 2)
                end
                if THead then
                    workspace.CurrentCamera.CameraSubject = THead
                elseif not THead and Handle then
                    workspace.CurrentCamera.CameraSubject = Handle
                elseif THumanoid and TRootPart then
                    workspace.CurrentCamera.CameraSubject = THumanoid
                end
                if not TCharacter:FindFirstChildWhichIsA("BasePart") then
                    return
                end
                
                local FPos = function(BasePart, Pos, Ang)
                    RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
                    Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
                    RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
                    RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
                end
                
                local SFBasePart = function(BasePart)
                    local TimeToWait = 2
                    local Time = tick()
                    local Angle = 0
                    repeat
                        if RootPart and THumanoid then
                            if BasePart.Velocity.Magnitude < 50 then
                                Angle = Angle + 100
                                FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 0.95, CFrame.Angles(math.rad(Angle),0 ,0))
                                task.wait()
                                FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 0.95, CFrame.Angles(math.rad(Angle), 0, 0))
                                task.wait()
                                FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 0.95, CFrame.Angles(math.rad(Angle), 0, 0))
                                task.wait()
                                FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 0.95, CFrame.Angles(math.rad(Angle), 0, 0))
                                task.wait()
                                FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                                task.wait()
                                FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                                task.wait()
                            else
                                FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                                task.wait()
                                FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                                task.wait()
                                FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                                task.wait()
                                
                                FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 0.95), CFrame.Angles(math.rad(90), 0, 0))
                                task.wait()
                                FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 0.95), CFrame.Angles(0, 0, 0))
                                task.wait()
                                FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 0.95), CFrame.Angles(math.rad(90), 0, 0))
                                task.wait()
                                FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                                task.wait()
                                FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                                task.wait()
                                FPos(BasePart, CFrame.new(0, -1.5 ,0), CFrame.Angles(math.rad(-90), 0, 0))
                                task.wait()
                                FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                                task.wait()
                            end
                        else
                            break
                        end
                    until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
                end
                
                workspace.FallenPartsDestroyHeight = 0/0
                
                local BV = Instance.new("BodyVelocity")
                BV.Name = "EpixVel"
                BV.Parent = RootPart
                BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
                BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)
                
                Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
                
                if TRootPart and THead then
                    if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
                        SFBasePart(THead)
                    else
                        SFBasePart(TRootPart)
                    end
                elseif TRootPart and not THead then
                    SFBasePart(TRootPart)
                elseif not TRootPart and THead then
                    SFBasePart(THead)
                elseif not TRootPart and not THead and Accessory and Handle then
                    SFBasePart(Handle)
                else
                    return Message("WX", "玩家已趋势", 2)
                end
                
                BV:Destroy()
                Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
                workspace.CurrentCamera.CameraSubject = Humanoid
                
                repeat
                    RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
                    Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, .5, 0))
                    Humanoid:ChangeState("GettingUp")
                    table.foreach(Character:GetChildren(), function(_, x)
                        if x:IsA("BasePart") then
                            x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
                        end
                    end)
                    task.wait()
                until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
                workspace.FallenPartsDestroyHeight = getgenv().FPDH
            else
                return Message("WX", "随机错误", 2)
            end
        end
        
        local hasPlayers = false
        for _,x in next, Players:GetPlayers() do
            if x ~= Player then
                hasPlayers = true
                break
            end
        end
        if not hasPlayers then
            return Message("WX", "无玩家可以甩飞", 2)
        end
        
        if Targets[1] then for _,x in next, Targets do GetPlayer(x) end else return end
        if AllBool then
            for _,x in next, Players:GetPlayers() do
                if x ~= Player then
                    SkidFling(x)
                end
            end
        end
        
        Message("WX", "正在甩飞所有玩家...", 3)
    end
})

-- 传送玩家前后方部分
TabHandles.WX4:Paragraph({
    Title = "精确位置传送",
    Desc = "传送到玩家的前后方、头顶等精确位置",
    Image = "target",
    ImageSize = 20
})

-- 传送前方的距离滑块
local frontDistance = 3
TabHandles.WX4:Slider({
    Title = "传送前方的距离",
    Desc = "设置传送到玩家前方的距离",
    Value = {
        Min = 1,
        Max = 50,
        Default = frontDistance
    },
    Step = 1,
    Callback = function(value)
        frontDistance = tonumber(value)
        WindUI:Notify({
            Title = "WX",
            Content = "前方距离设置为: " .. frontDistance,
            Duration = 3,
            Icon = "ruler"
        })
    end
})

-- 循环传送至玩家前方
local loopFrontTPConnection = nil
local loopFrontTPEnabled = false
TabHandles.WX4:Toggle({
    Title = "循环传送至玩家前方",
    Desc = "持续传送到选中玩家的前方",
    Value = false,
    Callback = function(state)
        loopFrontTPEnabled = state
        if state then
            WindUI:Notify({
                Title = "WX",
                Content = "前方传送已开启",
                Duration = 3,
                Icon = "check"
            })
            
            if loopFrontTPConnection then
                loopFrontTPConnection:Disconnect()
            end
            
            loopFrontTPConnection = RunService.Heartbeat:Connect(function()
                if not loopFrontTPEnabled or not selectedPlayer or not selectedPlayer.Character or not selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    if loopFrontTPConnection then
                        loopFrontTPConnection:Disconnect()
                        loopFrontTPConnection = nil
                    end
                    return
                end
                local targetCF = selectedPlayer.Character.HumanoidRootPart.CFrame
                local frontPos = targetCF.Position + targetCF.LookVector * frontDistance
                if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(frontPos)
                end
            end)
        else
            if loopFrontTPConnection then
                loopFrontTPConnection:Disconnect()
                loopFrontTPConnection = nil
            end
            WindUI:Notify({
                Title = "WX",
                Content = "前方传送已关闭",
                Duration = 3,
                Icon = "x"
            })
        end
    end
})

-- 传送头顶的距离滑块
local headDistance = 4
TabHandles.WX4:Slider({
    Title = "传送头顶的距离",
    Desc = "设置传送到玩家头顶的距离",
    Value = {
        Min = 1,
        Max = 50,
        Default = headDistance
    },
    Step = 1,
    Callback = function(value)
        headDistance = tonumber(value)
        WindUI:Notify({
            Title = "WX",
            Content = "头顶距离设置为: " .. headDistance,
            Duration = 3,
            Icon = "ruler"
        })
    end
})

-- 循环传送至玩家头顶
local loopHeadHeightConnection = nil
local loopHeadHeightEnabled = false
TabHandles.WX4:Toggle({
    Title = "循环传送至玩家头顶",
    Desc = "持续传送到选中玩家的头顶",
    Value = false,
    Callback = function(state)
        loopHeadHeightEnabled = state
        if state then
            WindUI:Notify({
                Title = "WX",
                Content = "头顶传送已开启",
                Duration = 3,
                Icon = "check"
            })
            
            if loopHeadHeightConnection then
                loopHeadHeightConnection:Disconnect()
            end
            
            loopHeadHeightConnection = RunService.Heartbeat:Connect(function()
                if not loopHeadHeightEnabled or not selectedPlayer or not selectedPlayer.Character or not selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    if loopHeadHeightConnection then
                        loopHeadHeightConnection:Disconnect()
                        loopHeadHeightConnection = nil
                    end
                    return
                end
                local targetPos = selectedPlayer.Character.HumanoidRootPart.Position
                if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(targetPos.X, targetPos.Y + headDistance, targetPos.Z)
                end
            end)
        else
            if loopHeadHeightConnection then
                loopHeadHeightConnection:Disconnect()
                loopHeadHeightConnection = nil
            end
            WindUI:Notify({
                Title = "WX",
                Content = "头顶传送已关闭",
                Duration = 3,
                Icon = "x"
            })
        end
    end
})

-- 传送后面的距离滑块
local backDistance = 2
TabHandles.WX4:Slider({
title="传送后面的距离"，
DESC="设置传送到玩家后面的距离"，
值={
min=1，
最大值=50，
默认值=backDistance
    },
步长=1，
回调=函数(值)
backDistance=tonumber(值)
WindUI：通知({
title="WX"，
内容="后面距离设置为："..backDistance，
持续时间=3，
图标="标尺"
        })
结束
})

-- 循环传送至玩家后面
local loopBackTPConnection=nil
local loopBackTPEnabled=false
TabHandles.WX4：切换({
标题="循环传送至玩家后面"，
DESC="持续传送到选中玩家的后面"，
值=false，
回调=函数(状态)
loopBackTPEnabled=状态
如果说明，则
WindUI：通知({
title="WX"，
内容="后面传送已开启"，
持续时间=3，
图标="检查"
            })
            
如果loopBackTPConnection，则
loopBackTPConnection:Disconnect()
结束
            
loopBackTPConnection=RunService。心跳：连接(函数()
如果不是loopBackTPEnabled或不是selectedPlayer或不是selectedPlayer.Character或不是selectedPlayer。角色：FindFirstChild("HumanoidRootPart")然后
如果loopBackTPConnection，则
loopBackTPConnection:Disconnect()
loopBackTPConnection=nil
结束
返回
结束
本地targetCF=selectedPlayer。性格。HumanoidRootPart.cframe
本地backPos=targetCF。位置-targetCF.外观矢量*backDistance
if game.Players.LocalPlayer.Character和游戏。玩家。本地玩家。角色：寻找第一个孩子(“HumanoidRootPart”)然后
游戏。玩家。本地玩家。性格。HumanoidRootPart.cframe=CFrame.new(backPos)
结束
结束)
其他
如果loopBackTPConnection，则
loopBackTPConnection:Disconnect()
loopBackTPConnection=nil
结束
WindUI：通知({
title="WX"，
内容="后面传送已关闭"，
持续时间=3，
图标="x"
            })
结束
结束
})

-- 初始化玩家列表
refreshPlayers()
--================甩飞标签页新增功能结束================
-- 最后通知
WindUI：通知({
title="WX脚本已加载"，
内容="欢迎使用WX多功能脚本！\n祝您游戏愉快！"，
图标="检查圆圈"，
持续时间=5
})
